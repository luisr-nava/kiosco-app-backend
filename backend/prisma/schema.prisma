generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"

  url = env("DATABASE_URL")
}

model Shop {
  id           String   @id @default(uuid())
  name         String
  address      String?
  ownerId      String
  createdAt    DateTime @default(now())
  projectId    String
  isActive     Boolean  @default(true)
  phone        String?
  countryCode  String   @default("US")
  currencyCode String   @default("USD")
  timezone     String   @default("UTC")

  // Configuración de alertas de stock
  lowStockThreshold Int? @default(10) // Umbral de stock bajo

  employeeShops           EmployeeShop[]
  expenses                Expense[]
  incomes                 Income[]
  purchases               Purchase[]
  sales                   Sale[]
  shopProducts            ShopProduct[]
  supplierShop            SupplierShop[]
  categories              Category[]
  supplierCategories      SupplierCategory[]
  saleReturns             SaleReturn[]
  purchaseReturns         PurchaseReturn[]
  creditNotes             CreditNote[]
  merchandiseReplacements MerchandiseReplacement[]
  customers               Customer[]
  cashRegisters           CashRegister[]
  paymentMethods          PaymentMethod[]
  stockAlerts             StockAlert[]
  measurementUnits        ShopMeasurementUnit[]
}

model Supplier {
  id          String   @id @default(uuid())
  name        String
  ownerId     String
  contactName String?
  phone       String?
  email       String?
  address     String?
  notes       String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  categoryId String?
  category   SupplierCategory? @relation(fields: [categoryId], references: [id])

  products                Product[]
  purchases               Purchase[]
  supplierShop            SupplierShop[]
  purchaseReturns         PurchaseReturn[]
  creditNotes             CreditNote[]
  merchandiseReplacements MerchandiseReplacement[]
}

model SupplierShop {
  id         String @id @default(uuid())
  supplierId String
  shopId     String

  supplier Supplier @relation(fields: [supplierId], references: [id])
  shop     Shop     @relation(fields: [shopId], references: [id])

  @@unique([supplierId, shopId])
}

model SupplierCategory {
  id     String @id @default(uuid())
  name   String
  shopId String

  shop Shop @relation(fields: [shopId], references: [id])

  // Auditoría
  createdAt DateTime @default(now())
  createdBy String? // quién la creó

  updatedAt DateTime @updatedAt
  updatedBy String? // quién la modificó

  isActive   Boolean   @default(true)
  disabledAt DateTime?
  disabledBy String? // quién la deshabilitó

  suppliers Supplier[]

  @@unique([name, shopId])
}

model Sale {
  id              String  @id @default(uuid())
  shopId          String
  customerId      String? // Cliente (opcional, puede ser venta al público)
  employeeId      String? // Empleado que realizó la venta
  cashRegisterId  String? // Caja donde se registró
  paymentMethodId String // Método de pago (obligatorio)

  // Montos
  subtotal       Float // Suma de items sin descuentos
  discountAmount Float @default(0) // Descuento total aplicado
  taxAmount      Float @default(0) // IVA total
  totalAmount    Float // Total final a pagar

  // Métodos de pago
  paymentStatus PaymentStatus @default(PAID)

  // Datos adicionales
  saleDate      DateTime     @default(now())
  notes         String?
  invoiceNumber String? // Número de factura (si aplica)
  invoiceType   InvoiceType? // Tipo de comprobante fiscal

  // Estado
  status   SaleStatus @default(COMPLETED)
  isActive Boolean    @default(true)

  // Cancelación
  cancelledAt        DateTime?
  cancelledBy        String? // User ID
  cancellationReason String?

  // Relaciones
  shop            Shop                     @relation(fields: [shopId], references: [id])
  customer        Customer?                @relation(fields: [customerId], references: [id])
  employee        Employee?                @relation(fields: [employeeId], references: [id])
  paymentMethod   PaymentMethod            @relation(fields: [paymentMethodId], references: [id])
  items           SaleItem[]
  history         SaleHistory[]
  itemHistory     SaleItemHistory[]
  saleReturns     SaleReturn[]             @relation("SaleToReturn")
  accountMovement CustomerAccountMovement?
  cashMovement    CashMovement?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([shopId, saleDate])
  @@index([customerId, saleDate])
  @@index([paymentMethodId])
  @@index([status, paymentStatus])
}

model SaleHistory {
  id        String            @id @default(uuid())
  saleId    String
  action    SaleHistoryAction
  snapshot  Json
  createdAt DateTime          @default(now())

  sale Sale @relation(fields: [saleId], references: [id])

  @@index([saleId])
}

enum SaleHistoryAction {
  CREATED
  UPDATED
  CANCELLED
}

model SaleItem {
  id            String @id @default(uuid())
  saleId        String
  shopProductId String

  // Cantidades y precios
  quantity  Decimal @db.Decimal(18, 6)
  unitPrice Float // Precio unitario al momento de la venta
  subtotal  Float // quantity * unitPrice
  discount  Float @default(0) // Descuento aplicado a este item
  taxRate   Float @default(0) // % de IVA
  taxAmount Float @default(0) // IVA calculado
  total     Float // Subtotal - discount + taxAmount

  // Relaciones
  sale        Sale        @relation(fields: [saleId], references: [id], onDelete: Cascade)
  shopProduct ShopProduct @relation(fields: [shopProductId], references: [id])

  createdAt DateTime @default(now())
}

model SaleItemHistory {
  id            String   @id @default(uuid())
  saleId        String
  shopProductId String
  previousQty   Int
  newQty        Int
  changedAt     DateTime @default(now())
  changedBy     String?

  sale Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)

  @@index([saleId])
}

// Enums para ventas
model PaymentMethod {
  id          String   @id @default(uuid())
  shopId      String
  name        String // Nombre del método (ej: "Efectivo", "Tarjeta Débito")
  code        String // Código único (ej: "CASH", "DEBIT_CARD")
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  shop             Shop              @relation(fields: [shopId], references: [id])
  sales            Sale[]
  purchases        Purchase[]
  incomes          Income[]
  expenses         Expense[]
  customerPayments CustomerPayment[]

  @@unique([shopId, code])
  @@index([shopId, isActive])
}

enum PaymentStatus {
  PENDING // Pendiente de pago
  PAID // Pagado
  PARTIAL // Pago parcial
  OVERDUE // Vencido (cuenta corriente)
  CANCELLED // Cancelado
}

enum SaleStatus {
  DRAFT // Borrador (no finalizada)
  COMPLETED // Completada
  CANCELLED // Cancelada
  RETURNED // Devuelta (total o parcial)
}

enum InvoiceType {
  TICKET // Ticket no fiscal
  FACTURA_A // Factura A (responsables inscriptos)
  FACTURA_B // Factura B (consumidor final)
  FACTURA_C // Factura C (monotributista)
  NOTA_CREDITO_A // Nota de crédito A
  NOTA_CREDITO_B // Nota de crédito B
  NOTA_CREDITO_C // Nota de crédito C
}

// Devoluciones de ventas (clientes devuelven productos)
model SaleReturn {
  id          String           @id @default(uuid())
  saleId      String? // Opcional, puede ser una devolución sin venta específica
  sale        Sale?            @relation("SaleToReturn", fields: [saleId], references: [id])
  shopId      String
  totalAmount Float
  reason      String
  returnDate  DateTime         @default(now())
  status      SaleReturnStatus @default(PENDING)

  // Qué se hizo con el dinero
  refundType   RefundType @default(CASH) // CASH, CREDIT, EXCHANGE
  refundAmount Float // Monto efectivamente devuelto

  notes String?

  shop            Shop             @relation(fields: [shopId], references: [id])
  items           SaleReturnItem[]
  purchaseReturns PurchaseReturn[] // Devoluciones al proveedor generadas
  cashMovement    CashMovement?
}

model SaleReturnItem {
  id            String  @id @default(uuid())
  saleReturnId  String
  shopProductId String
  quantity      Int
  unitPrice     Float
  subtotal      Float
  reason        String? // Razón específica del producto
  condition     String? // Estado del producto (DEFECTIVE, EXPIRED, etc)

  saleReturn  SaleReturn  @relation(fields: [saleReturnId], references: [id], onDelete: Cascade)
  shopProduct ShopProduct @relation(fields: [shopProductId], references: [id])
}

// Devoluciones a proveedores
model PurchaseReturn {
  id           String               @id @default(uuid())
  purchaseId   String? // Compra original (opcional)
  supplierId   String
  shopId       String
  saleReturnId String? // Si viene de una devolución de venta
  totalAmount  Float
  returnDate   DateTime             @default(now())
  status       PurchaseReturnStatus @default(PENDING)

  // Tipo de resolución
  resolutionType ResolutionType @default(CREDIT_NOTE) // CREDIT_NOTE, REPLACEMENT, REFUND

  reason String
  notes  String?

  supplier    Supplier                @relation(fields: [supplierId], references: [id])
  shop        Shop                    @relation(fields: [shopId], references: [id])
  saleReturn  SaleReturn?             @relation(fields: [saleReturnId], references: [id])
  items       PurchaseReturnItem[]
  creditNote  CreditNote? // Si se generó nota de crédito
  replacement MerchandiseReplacement? // Si se generó reposición
}

model PurchaseReturnItem {
  id               String  @id @default(uuid())
  purchaseReturnId String
  shopProductId    String
  quantity         Int
  unitCost         Float
  subtotal         Float
  reason           String?

  purchaseReturn PurchaseReturn @relation(fields: [purchaseReturnId], references: [id], onDelete: Cascade)
  shopProduct    ShopProduct    @relation(fields: [shopProductId], references: [id])
}

// Notas de crédito de proveedores
model CreditNote {
  id               String           @id @default(uuid())
  purchaseReturnId String           @unique
  supplierId       String
  shopId           String
  amount           Float
  remainingAmount  Float // Monto disponible
  issueDate        DateTime         @default(now())
  expiryDate       DateTime? // Fecha de vencimiento (opcional)
  status           CreditNoteStatus @default(ACTIVE)
  notes            String?

  purchaseReturn PurchaseReturn          @relation(fields: [purchaseReturnId], references: [id])
  supplier       Supplier                @relation(fields: [supplierId], references: [id])
  shop           Shop                    @relation(fields: [shopId], references: [id])
  applications   CreditNoteApplication[] // Usos de la nota de crédito
}

model CreditNoteApplication {
  id              String   @id @default(uuid())
  creditNoteId    String
  purchaseId      String
  amountApplied   Float
  applicationDate DateTime @default(now())
  notes           String?

  creditNote CreditNote @relation(fields: [creditNoteId], references: [id])
  purchase   Purchase   @relation(fields: [purchaseId], references: [id])
}

// Reposiciones de mercadería
model MerchandiseReplacement {
  id               String            @id @default(uuid())
  purchaseReturnId String            @unique
  supplierId       String
  shopId           String
  status           ReplacementStatus @default(PENDING)
  requestDate      DateTime          @default(now())
  deliveryDate     DateTime?
  notes            String?

  purchaseReturn PurchaseReturn    @relation(fields: [purchaseReturnId], references: [id])
  supplier       Supplier          @relation(fields: [supplierId], references: [id])
  shop           Shop              @relation(fields: [shopId], references: [id])
  items          ReplacementItem[]
}

model ReplacementItem {
  id                       String @id @default(uuid())
  merchandiseReplacementId String
  shopProductId            String
  requestedQuantity        Int
  deliveredQuantity        Int    @default(0)

  replacement MerchandiseReplacement @relation(fields: [merchandiseReplacementId], references: [id], onDelete: Cascade)
  shopProduct ShopProduct            @relation(fields: [shopProductId], references: [id])
}

// Enums
enum SaleReturnStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSED
}

enum PurchaseReturnStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSED
}

enum PurchaseStatus {
  COMPLETED
  CANCELLED
}

enum RefundType {
  CASH // Devolución en efectivo
  CREDIT // Crédito en tienda
  EXCHANGE // Cambio de producto
}

enum ResolutionType {
  CREDIT_NOTE // Nota de crédito
  REPLACEMENT // Reposición de mercadería
  REFUND // Devolución de dinero
}

enum CreditNoteStatus {
  ACTIVE
  PARTIALLY_USED
  FULLY_USED
  EXPIRED
  CANCELLED
}

enum ReplacementStatus {
  PENDING
  IN_TRANSIT
  DELIVERED
  CANCELLED
}

model Purchase {
  id                     String                  @id @default(uuid())
  supplierId             String?
  shopId                 String
  paymentMethodId        String
  totalAmount            Float?
  purchaseDate           DateTime                @default(now())
  status                 PurchaseStatus          @default(COMPLETED)
  notes                  String?
  cancelledAt            DateTime?
  cancelledBy            String?
  cancellationReason     String?
  histories              ProductHistory[]
  shop                   Shop                    @relation(fields: [shopId], references: [id])
  supplier               Supplier?               @relation(fields: [supplierId], references: [id])
  paymentMethod          PaymentMethod           @relation(fields: [paymentMethodId], references: [id])
  items                  PurchaseItem[]
  creditNoteApplications CreditNoteApplication[]
  cashMovement           CashMovement?

  @@index([paymentMethodId])
}

model PurchaseItem {
  id            String      @id @default(uuid())
  purchaseId    String
  shopProductId String
  quantity      Int
  unitCost      Float
  subtotal      Float
  purchase      Purchase    @relation(fields: [purchaseId], references: [id])
  shopProduct   ShopProduct @relation(fields: [shopProductId], references: [id])
}

model PurchaseDeletionHistory {
  id            String   @id @default(uuid())
  purchaseId    String // ID de la compra eliminada
  shopId        String
  shopName      String
  supplierId    String?
  supplierName  String?
  totalAmount   Float?
  purchaseDate  DateTime
  originalNotes String?

  // Datos de la eliminación
  deletedBy      String // User ID
  deletedByEmail String
  deletedAt      DateTime @default(now())
  deletionReason String // Razón obligatoria de eliminación

  // JSON con los items de la compra
  itemsSnapshot String @db.Text // Guardamos los items en formato JSON
}

model MeasurementUnit {
  id               String                  @id @default(uuid())
  name             String
  code             String
  category         MeasurementUnitCategory?
  baseUnit         MeasurementBaseUnit?
  conversionFactor Decimal                 @db.Decimal(18, 6) @default(1)
  isBaseUnit       Boolean                 @default(false)
  isDefault        Boolean                 @default(false)
  createdByUserId  String?
  createdAt        DateTime                @default(now())

  shopMeasurementUnits ShopMeasurementUnit[]
  products             Product[]

  @@unique([code])
}

model ShopMeasurementUnit {
  id                String   @id @default(uuid())
  shopId            String
  measurementUnitId String
  assignedByUserId  String?
  createdAt         DateTime @default(now())

  shop            Shop            @relation(fields: [shopId], references: [id], onDelete: Cascade)
  measurementUnit MeasurementUnit @relation(fields: [measurementUnitId], references: [id], onDelete: Cascade)

  @@unique([shopId, measurementUnitId])
  @@index([measurementUnitId])
}

model Product {
  id          String   @id @default(uuid())
  name        String
  description String?
  barcode     String?
  createdAt   DateTime @default(now())
  taxCategory String?
  taxRate     Float?
  allowPriceOverride Boolean @default(false)

  supplierId String?
  supplier   Supplier? @relation(fields: [supplierId], references: [id])

  categoryId        String? // <--- agregado
  category          Category?       @relation(fields: [categoryId], references: [id])
  measurementUnitId String
  measurementUnit   MeasurementUnit @relation(fields: [measurementUnitId], references: [id])

  shopProducts ShopProduct[]
}

model ShopProduct {
  id                  String               @id @default(uuid())
  shopId              String
  productId           String
  costPrice           Float
  salePrice           Float
  stock               Int?
  createdAt           DateTime             @default(now())
  createdBy           String?
  currency            String               @default("USD")
  isActive            Boolean              @default(true)
  productHistories    ProductHistory[]
  purchaseItems       PurchaseItem[]
  product             Product              @relation(fields: [productId], references: [id])
  shop                Shop                 @relation(fields: [shopId], references: [id])
  saleReturnItems     SaleReturnItem[]
  purchaseReturnItems PurchaseReturnItem[]
  replacementItems    ReplacementItem[]
  saleItems           SaleItem[]
  stockAlerts         StockAlert[]

  @@unique([shopId, productId])
}

model ProductHistory {
  id            String      @id @default(uuid())
  shopProductId String
  userId        String?
  purchaseId    String?
  changeType    String
  previousCost  Float?
  newCost       Float?
  previousStock Int?
  newStock      Int?
  note          String?
  createdAt     DateTime    @default(now())
  purchase      Purchase?   @relation(fields: [purchaseId], references: [id])
  shopProduct   ShopProduct @relation(fields: [shopProductId], references: [id])
}

model Income {
  id              String        @id @default(uuid())
  shopId          String
  paymentMethodId String
  amount          Float
  description     String
  category        String?
  date            DateTime      @default(now())
  createdBy       String?
  shop            Shop          @relation(fields: [shopId], references: [id])
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id])
  cashMovement    CashMovement?

  @@index([paymentMethodId])
}

model Expense {
  id              String        @id @default(uuid())
  shopId          String
  paymentMethodId String
  amount          Float
  description     String
  category        String?
  date            DateTime      @default(now())
  createdBy       String?
  shop            Shop          @relation(fields: [shopId], references: [id])
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id])
  cashMovement    CashMovement?

  @@index([paymentMethodId])
}

model Employee {
  id               String         @id @default(uuid())
  fullName         String
  email            String         @unique
  role             String
  hireDate         DateTime?
  salary           Float?
  address          String?
  createdAt        DateTime       @default(now())
  dni              String?
  emergencyContact String?
  isActive         Boolean        @default(true)
  notes            String?
  phone            String?
  profileImage     String?
  sales            Sale[]
  employeeShops    EmployeeShop[]
}

model EmployeeShop {
  id         String   @id @default(uuid())
  employeeId String
  shopId     String
  createdAt  DateTime @default(now())

  employee Employee @relation(fields: [employeeId], references: [id])
  shop     Shop     @relation(fields: [shopId], references: [id])

  @@unique([employeeId, shopId])
  @@index([shopId])
}

model NotificationPreference {
  id                String   @id @default(uuid())
  userId            String
  shopId            String
  lowStockEnabled   Boolean  @default(true)
  lowStockThreshold Int      @default(5)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, shopId])
  @@index([shopId])
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  shopId    String
  type      NotificationType
  title     String
  message   String

  read      Boolean          @default(false)
  readAt    DateTime?

  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  deletedAt DateTime?

  @@index([userId, read])
  @@index([userId, createdAt])
  @@index([shopId])
}

enum NotificationType {
  LOW_STOCK
  STOCK_OUT
  SALE_CREATED
  PURCHASE_CREATED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  CUSTOMER_CREATED
}

model Customer {
  id     String @id @default(uuid())
  shopId String

  // Datos personales
  fullName String
  email    String?
  phone    String?
  dni      String?
  address  String?

  // Cuenta corriente
  creditLimit    Float? // Límite de crédito
  currentBalance Float @default(0) // Saldo actual (lo que debe)

  // Estado
  isActive Boolean @default(true)
  notes    String?

  // Fechas
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  shop             Shop                      @relation(fields: [shopId], references: [id])
  sales            Sale[]
  payments         CustomerPayment[]
  accountMovements CustomerAccountMovement[]

  @@unique([shopId, dni], map: "Customer_shopId_dni_unique") // DNI único por tienda
  @@index([shopId, isActive])
}

model CustomerPayment {
  id              String @id @default(uuid())
  customerId      String
  shopId          String
  paymentMethodId String // Método de pago usado

  // Monto
  amount Float

  // Referencia
  referenceNumber String? // Número de comprobante, transferencia, etc.
  notes           String?

  // Fechas
  paymentDate DateTime @default(now())
  createdAt   DateTime @default(now())

  // Relaciones
  customer      Customer                 @relation(fields: [customerId], references: [id])
  paymentMethod PaymentMethod            @relation(fields: [paymentMethodId], references: [id])
  movement      CustomerAccountMovement?

  @@index([customerId, paymentDate])
  @@index([paymentMethodId])
}

model CustomerAccountMovement {
  id         String @id @default(uuid())
  customerId String
  shopId     String

  // Tipo de movimiento
  type   AccountMovementType
  amount Float

  // Saldo antes y después
  previousBalance Float
  newBalance      Float

  // Referencias
  saleId    String? @unique
  paymentId String? @unique

  // Detalles
  description String?

  // Fecha
  createdAt DateTime @default(now())

  // Relaciones
  customer Customer         @relation(fields: [customerId], references: [id])
  sale     Sale?            @relation(fields: [saleId], references: [id])
  payment  CustomerPayment? @relation(fields: [paymentId], references: [id])

  @@index([customerId, createdAt])
  @@index([shopId, createdAt])
}

enum AccountMovementType {
  SALE // Venta a crédito (aumenta deuda)
  PAYMENT // Pago (reduce deuda)
  ADJUSTMENT // Ajuste manual
}

model Category {
  id     String @id @default(uuid())
  name   String
  shopId String

  // Auditoría
  createdAt DateTime @default(now())
  createdBy String? // <-- quién la creó

  updatedAt DateTime @updatedAt
  updatedBy String? // <-- quién la modificó

  isActive   Boolean   @default(true)
  disabledAt DateTime? // <-- cuándo se deshabilitó
  disabledBy String? // <-- quién la deshabilitó

  shop     Shop      @relation(fields: [shopId], references: [id])
  products Product[]

  @@unique([name, shopId])
}

model CashRegister {
  id             String    @id @default(uuid())
  shopId         String
  employeeId     String
  openingAmount  Float // Monto inicial al abrir
  openedAt       DateTime  @default(now())
  openedByUserId String?
  openedByName   String?
  closingAmount  Float? // Monto al cerrar (esperado según ventas)
  actualAmount   Float? // Monto real contado
  difference     Float? // Diferencia (falta/sobrante)
  closedAt       DateTime?
  closedBy       String? // User ID
  closingNotes   String?

  // Estado
  status CashRegisterStatus @default(OPEN)

  // Relaciones
  shop      Shop                 @relation(fields: [shopId], references: [id])
  movements CashMovement[]
  exports   CashRegisterExport[]

  @@index([shopId, status])
  @@index([openedAt])
}

model CashMovement {
  id             String @id @default(uuid())
  cashRegisterId String
  shopId         String

  // Tipo y monto
  type        CashMovementType
  amount      Float
  description String?

  // Referencia
  saleId       String? @unique
  purchaseId   String? @unique
  saleReturnId String? @unique
  incomeId     String? @unique
  expenseId    String? @unique
  userId       String

  // Fecha
  createdAt DateTime @default(now())

  // Relaciones
  cashRegister CashRegister @relation(fields: [cashRegisterId], references: [id])
  sale         Sale?        @relation(fields: [saleId], references: [id])
  purchase     Purchase?    @relation(fields: [purchaseId], references: [id])
  saleReturn   SaleReturn?  @relation(fields: [saleReturnId], references: [id])
  income       Income?      @relation(fields: [incomeId], references: [id])
  expense      Expense?     @relation(fields: [expenseId], references: [id])

  @@index([cashRegisterId, createdAt])
  @@index([shopId, createdAt])
}

enum CashRegisterStatus {
  OPEN // Caja abierta
  CLOSED // Caja cerrada
  CANCELLED // Caja cancelada
}

enum CashMovementType {
  SALE // Venta en efectivo (ingreso)
  PURCHASE // Pago a proveedor (egreso)
  RETURN // Devolución de venta (egreso)
  INCOME // Ingreso extra
  EXPENSE // Egreso
  OPENING // Apertura de caja
  WITHDRAWAL // Retiro de efectivo
  DEPOSIT // Depósito adicional
  ADJUSTMENT // Ajuste manual
}

enum CashRegisterExportFormat {
  PDF
  EXCEL
}

model CashRegisterExport {
  id             String                   @id @default(uuid())
  cashRegisterId String
  format         CashRegisterExportFormat
  url            String
  contentType    String
  expiresAt      DateTime
  createdAt      DateTime                 @default(now())

  cashRegister CashRegister @relation(fields: [cashRegisterId], references: [id])

  @@index([cashRegisterId, format, expiresAt])
}

enum SubscriptionStatus {
  FREE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
}

enum MeasurementUnitCategory {
  UNIT
  WEIGHT
  VOLUME
}

enum MeasurementBaseUnit {
  UNIT
  KG
  L
}

model StockAlert {
  id            String @id @default(uuid())
  shopId        String
  shopProductId String

  // Stock info
  currentStock Int
  threshold    Int // Umbral que disparó la alerta

  // Estado
  isResolved Boolean   @default(false)
  resolvedAt DateTime?

  // Metadata
  createdAt  DateTime  @default(now())
  notifiedAt DateTime? // Cuándo se envió la notificación

  notificationId String? // Referencia opcional que puede guardarse en el servicio

  // Relaciones
  shop        Shop        @relation(fields: [shopId], references: [id], onDelete: Cascade)
  shopProduct ShopProduct @relation(fields: [shopProductId], references: [id], onDelete: Cascade)

  @@index([shopId, isResolved])
  @@index([shopProductId, isResolved])
}

model Subscription {
  id               String             @id @default(uuid())
  projectId        String             @unique
  ownerId          String
  plan             String             @default("FREE")
  status           SubscriptionStatus @default(FREE)
  currentPeriodEnd DateTime?
  cancelAt         DateTime?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  @@index([ownerId])
  @@index([status])
}
